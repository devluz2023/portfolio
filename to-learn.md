Senior Software Engineer, Artificial Intelligence
Minimum qualifications:
Bachelor’s degree or equivalent practical experience.
Candidates will typically have 5 years of experience with software development in one or more programming languages, and with data structures/algorithms.
Typically 3 years of experience testing, maintaining, or launching software products, and 1 year of experience with software design and architecture.
Experience in AI/ML related engineering, developing, deploying, managing, and maintaining Machine Learning infrastructure.
Experience in Python and deep learning for computer vision and NLP.

Preferred qualifications:
Master's degree or PhD in Computer Science or a related technical field.
Understanding of data engineering practices and principles (e.g., tools, processes, pipelines etc.).
Excellent communication and collaboration skills.

About the job
Google's software engineers develop the next-generation technologies that change how billions of users connect, explore, and inte
ract with information and one another. Our products need to handle information at massive scale, and extend well beyond web search. We're looking for engineers who bring fresh ideas from all areas, including information retrieval, distributed computing, large-scale system design, networking and data storage, security, artificial intelligence, natural language processing, UI design and mobile; the list goes on and is growing every day. As a software engineer, you will work on a specific project critical to Google’s needs with opportunities to switch teams and projects as you and our fast-paced business grow and evolve. We need our engineers to be versatile, display leadership qualities and be enthusiastic to take on new problems across the full-stack as we continue to push technology forward.

Our AI and Engineering teams work alongside our pedagogy team to surface high-quality, accurate content that reflects the clearest and most modern ways to explain and solve math problems.

Learning is the ongoing quest for understanding, and we made it our mission more than 20 years ago to organize the world’s information to make it universally accessible and useful. The learning landscape is changing, and the Learning and Education team's mission is to help everyone in the world learn anything in the world. We provide the information, tools, and services that help people gain knowledge, fuel curiosity, and prepare for what’s next. We focus our work to add the most value for users to enable learning for school, work, and life. We believe everyone can and should have access to quality learning experiences to reach their full potential.

Responsibilities
Research, develop, plan, and implement Machine Learning software solutions. Develop, manage, and maintain Machine Learning infrastructure.
Work with other team members to build upon our data collection, storage, and processing infrastructure.
Propose new ideas how AI can improve our products and internal processes and systems.
Conduct research and implement solutions by following best practices of software engineering and maintaining high precision and scientific principles.
Propose improvements of the team's processes and practices. Demonstrate growth mindset, self-reflection and provide feedback to other team members, peers, and managers.

The Senior Software Engineer – Cloud Infrastructure will develop and operate our planet-scale
Kubernetes Platform for running microservices to power our Observability and Security
products across the world. Will provide consistent and seamless interfaces that enable our
microservices to leverage key Kubernetes and underlying cloud features. Allow microservices to
run securely and efficiently without interruption. Make your customers developers happy!

CONHECIMENTOS BÁSICOS PARA TODOS OS CARGOS

# LÍNGUA PORTUGUESA (25):

1. Compreensão e interpretação de textos de gêneros variados.
2. Reconhecimento de tipos e gêneros textuais. 3 Domínio da ortografia oficial. 4 Domínio dos mecanismos de
   coesão textual. 4.1 Emprego de elementos de referenciação, substituição e repetição, de conectores e de
   outros elementos de sequenciação textual. 4.2 Emprego de tempos e modos verbais. 5 Domínio da estrutura
   morfossintática do período. 5.1 Emprego das classes de palavras. 5.2 Relações de coordenação entre orações
   e entre termos da oração. 5.3 Relações de subordinação entre orações e entre termos da oração. 5.4 Emprego
   dos sinais de pontuação. 5.5 Concordância verbal e nominal. 5.6 Regência verbal e nominal. 5.7 Emprego do
   sinal indicativo de crase. 5.8 Colocação dos pronomes átonos. 6 Reescrita de frases e parágrafos do texto. 6.1
   Significação das palavras. 6.2 Substituição de palavras ou de trechos de texto. 6.3 Reorganização da estrutura
   de orações e de períodos do texto. 6.4 Reescrita de textos de diferentes gêneros e níveis de formalidade.

NOÇÕES DE LÓGICA E ESTATÍSTICA (10): 1 Raciocínio lógico. 1.1 Estruturas lógicas. 1.2 Lógica de
argumentação: analogias, inferências, deduções e conclusões. 1.3 Lógica sentencial (ou proposicional). 10.3.1
Proposições simples e compostas. 10.3.2 Tabelas-verdade. 10.3.3 Equivalências. 10.3.4 Leis de Morgan;
problemas. 2 Noções de estatística. 2.1 População e amostra. 2.2 Histogramas e curvas de frequência. 2.3
Medidas de posição: média, moda, mediana e separatrizes. 2.4 Medidas de dispersão absoluta e relativa. 2.5
Probabilidade condicional, independência. 2.6 Variável aleatória e funções de distribuição.

DIREITO ADMINISTRATIVO (5): 1 Administração pública: princípios básicos. 1.1 Administração direta e
indireta. 2 Poderes administrativos. 2.1 Espécies de poder: hierárquico, cd disciplinar, regulamentar, de polícia e
normativo. 2.2 Uso e abuso do poder. 3 Organização administrativa brasileira. 3.1 Serviços públicos: conceito
e princípios. 3.2 Autarquias, agências reguladoras, agências executivas, fundações públicas, empresas
públicas, sociedades de economia mista. 4 Ato administrativo. 4.1 Conceito, requisitos e atributos. 4.2
Comunicação dos atos administrativos. 4.3 Anulação, revogação e convalidação. 4.4 Discricionariedade e
vinculação. 5 Servidores públicos: cargo, emprego e função públicos. 5.1 Lei nº 8.112/1990 (Regime Jurídico
dos Servidores Públicos Civis da União) e alterações. 5.1.1 Disposições preliminares. 5.1.2 Provimento,
vacância, remoção, redistribuição e substituição. 5.1.3 Direitos e vantagens. 5.1.4 Regime disciplinar. 5.1.5
Seguridade social do servidor: aposentadoria e pensão civil. 5.1.6 Processo administrativo disciplinar. 6
Improbidade administrativa. 7 Código de Ética Profissional do Servidor Público Civil do Poder Executivo
Federal (Decreto nº 1.171/1994). 8 Código de Conduta da Alta Administração Federal. 9 Lei de conflito de
interesses (Lei nº 11.813/2013). 10 Lei de Acesso à Informação (Lei nº 12.527/2011). 11 Lei nº 13.709/2018
(Lei Geral de Proteção de Dados Pessoais).

FUNDAMENTOS DE MACROECONOMIA E MICROECONOMIA (10): I MACROECONOMIA: 1 Contas nacionais.
2 Agregados monetários. 3 Multiplicador monetário, criação e destruição de moeda. 4 Contas do sistema
monetário. 5 Balanço de pagamentos. II MICROECONOMIA: 1 Estrutura de mercado. 1.1 Formas de
organização da atividade econômica, o papel dos preços, custo de oportunidade e fronteiras das
possibilidades de produção. 2 Oferta e demanda. 2.1 Curvas de indiferença. 2.2 Restrição orçamentária. 2.3
Equilíbrio do consumidor. 2.4 Efeitos preço, renda e substituição. 2.5 Curva de demanda. 2.6 Elasticidade da
demanda.

ATUALIDADES (SOMENTE PARA A PROVA DISCURSIVA): 1 Tópicos relevantes e atuais de diversas áreas, tais
como segurança, transportes, política, economia, sociedade, educação, saúde, cultura, tecnologia, energia,
relações internacionais, desenvolvimento sustentável e ecologia.

CONHECIMENTOS ESPECÍFICOS
CARGO 1: ANALISTA - ÁREA 1 - TECNOLOGIA DA INFORMAÇÃO
CIÊNCIA DE DADOS (14): 1 Aprendizado de Máquina. 2 Deep learning. 3 Processamento de linguagem natural.
4 Big data. 5 Qualidade de Dados. 6 Tipos de Aprendizado: Supervisionado, Não Supervisionado, Semi
Supervisionado, Por Reforço, Por Transferência. 7 Grandes Modelos de Linguagem (LLM), IA Generativa. 8
Redes Neurais. 9 MLOps: Gestão de código, treinamento, implantação, monitoramento e versionamento de
modelos, automação do ciclo de produção. 10 Governança e Ética na IA: Transparência, Responsabilidade,
Explicabilidade, Privacidade, Segurança, Viés.

SEGURANÇA DA INFORMAÇÃO (7): 1 Gestão de Identidades e Acesso: Autenticação e Autorização, Single
Sign-On (SSO), Security Assertion Markup Language (SAML), OAuth2 e OpenId Connect. 2 Privacidade e
segurança por padrão. 3 Principais tipos de ataques e vulnerabilidades. 4 Controles e testes de segurança
para aplicações Web e Web Services. 5 Múltiplos Fatores de Autenticação (MFA). 6 Soluções para Segurança
da Informação: Firewall, Intrusion Detection System (IDS), Intrusion Prevention System (IPS), Security
Information and Event Management (SIEM), Proxy, Identity Access Management (IAM), Privileged Access
Management (PAM), Antivírus, Antispam. 7 Frameworks de segurança da informação e segurança
cibernética, como, por exemplo, MITRE ATT&CK, CIS Controls e NIST CyberSecurity Framework (NIST CSF). 8
Tratamento de Incidentes Cibernéticos. 9 Assinatura e certificação digital, criptografia e proteção de dados
em trânsito e em repouso. 10 Segurança em nuvens e de contêineres.

ENGENHARIA DE SOFTWARE (24): 1 Arquitetura de sistemas web: protocolo HTTP, HTTP/2, gRPC,
WebSockets, TLS, servidores proxy, cache, DNS, balanceamento de carga, tolerância a falhas e escalabilidade
em sistemas web. 2 Princípios e práticas de DevOps e DevSecOps, integração e entrega contínuas (CI/CD). 3
Técnicas de desenvolvimento seguro. 4 Testes de software: Testes unitários, Testes de Integração, TDD, BDD.
5 Arquiteturas em camadas, baseada em serviços, microsserviços (orquestração de serviços e API gateway),
orientação a eventos, cliente-servidor, serverless. 6 Práticas de UX e UI design. 7 Programação assíncrona. 8
RESTful e GraphQL. 9 Web services. 10 Padrões: GoF e GRASP. 11 Git. 12 Python e Java. 13 Transações
distribuídas. 14 Distributed Ledger Technology (DLT).

INFRAESTRUTURA EM TI (17): 1 Conceitos de infraestrutura como código e automação de infraestrutura de
TI. 2 Docker, Kubernetes: boas práticas para infraestrutura e orquestração de containers. 3 Serviços de Rede
Microsoft Windows Server: DNS, DHCP, Radius, Autenticação, Certificados, Active Directory (AD). 4
Monitoração, observabilidade e análise de sistemas em produção por meio do uso de ferramentas de
monitoramento e logging, como o Nagios, Prometheus, Grafana, Elasticsearch, Kibana, Application
Performance Monitoring (APM), entre outras. 5 Protocolos da camada de aplicação, como Simple Mail
Transfer Protocol (SMTP), Hypertext Transfer Protocol (HTTP), Hypertext Transfer Protocol (HTTPS), SSL/TLS,
Lightweight Directory Access Protocol (LDAP), Network File System (NFS), Server Message Block (SMB). 6
Tolerância a falhas e continuidade de operação. 7 Implantação e administração de serviços de nuvem (IaaS,
PaaS e SaaS). 8 Administração e gerenciamento de ambientes de virtualização. 9 Administração e operação
de sistemas operacionais Microsoft Windows Server e Linux. 10 Conceitos de LAN, WAN e SDN. 11 Conceitos
e ferramentas de orquestração e automação de infraestrutura: Puppet, Ansible.

BANCOS DE DADOS (4): 1 SGBDs SQL e NOSQL. 2 Modelagens de dados: relacional, multidimensional, nosql.
3 SQL (Procedural Language / Structured Query Language). 4 Arquitetura de Inteligência de Negócio:
DataWarehouse, DataMart, DataLake, DataMesh.

GESTÃO EM TI (4): 1 Kanban. 2 Scrum. 3 Governança de Dados. 4 ITIL v4.

# Agile data science

Preface, Part I. Setup, 1. Theory:
Introduction, Definition, Methodology as Tweet, Agile Data Science Manifesto, The Problem with the Waterfall, Research Versus Application Development, The Problem with Agile Software, Eventual Quality: Financing Technical Debt, The Pull of the Waterfall, The Data Science Process, Setting Expectations, Data Science Team Roles, Recognizing the Opportunity and the Problem, Adapting to Change, Notes on Process, Code Review and Pair Programming, Agile Environments: Engineering Productivity, Realizing Ideas with Large-Format Printing,
Agile Tools:
Scalability = Simplicity, Agile Data Science Data Processing, Local Environment Setup, System Requirements, Setting Up Vagrant, Downloading the Data (EC2 Environment Setup), Getting and Running the Code (Jupyter Notebooks), Touring the Toolset, Agile Stack Requirements (Python 3, Serializing Events with JSON Lines and Parquet, Collecting Data, Data Processing with Spark, Publishing Data with MongoDB, Searching Data with Elasticsearch, Distributed Streams with Apache Kafka, Processing Streams with PySpark Streaming, Machine Learning with scikit-learn and Spark MLlib, Scheduling with Apache Airflow (Incubating), Reflecting on Our Workflow, Lightweight Web Applications, Presenting Our Data,
Data:
Air Travel Data, Flight On-Time Performance Data, OpenFlights Database, Weather Data, Data Processing in Agile Data Science, Structured Versus Semistructured Data, SQL Versus NoSQL, Spark: SQL + NoSQL, Schemas in NoSQL, Data Serialization, Extracting and Exposing Features in Evolving Schemas,
Part II. Climbing the Pyramid, 4. Collecting and Displaying Records:
Putting It All Together, Collecting and Serializing Flight Data, Processing and Publishing Flight Records, Publishing Flight Records to MongoDB, Presenting Flight Records in a Browser, Serving Flights with Flask and pymongo, Rendering HTML5 with Jinja2, Agile Checkpoint, Listing Flights, Paginating Data, Searching for Flights, Creating Our Index, Publishing Flights to Elasticsearch, Searching Flights on the Web,
Visualizing Data with Charts and Tables:
Chart Quality: Iteration Is Essential, Scaling a Database in the Publish/Decorate Model, Exploring Seasonality, Querying and Presenting Flight Volume, Extracting Metal (Airplanes [Entities]), Extracting Tail Numbers, Assessing Our Airplanes, Data Enrichment, Reverse Engineering a Web Form, Gathering Tail Numbers, Automating Form Submission, Extracting Data from HTML, Evaluating Enriched Data,
Exploring Data with Reports:
Extracting Airlines (Entities), Defining Airlines as Groups of Airplanes Using PySpark, Querying Airline Data in Mongo, Building an Airline Page in Flask, Linking Back to Our Airline Page, Creating an All Airlines Home Page, Curating Ontologies of Semi-structured Data, Improving Airlines, Adding Names to Carrier Codes, Incorporating Wikipedia Content, Publishing Enriched Airlines to Mongo, Enriched Airlines on the Web, Investigating Airplanes (Entities),
Making Predictions:
The Role of Predictions, Predict What?, Introduction to Predictive Analytics, Making Predictions, Exploring Flight Delays, Extracting Features with PySpark, Building a Regression with scikit-learn, Building a Classifier with Spark MLlib,
Deploying Predictive Systems:
Deploying a scikit-learn Application as a Web Service, Deploying Spark ML Applications in Batch with Airflow, Automating Our Workflow with Apache Airflow (Incubating), Deploying Spark ML via Spark Streaming,
Improving Predictions:
Fixing Our Prediction Problem, When to Improve Predictions, Improving Prediction Performance, Time of Day as a Feature, Incorporating Airplane Data, Incorporating Flight Time,

# Introduction to statical learning

Preface, Introduction, Statistical Learning, What Is Statistical Learning?, Why Estimate f?, How Do We Estimate f?, The Trade-Off Between Prediction Accuracy and Model Interpretability, Supervised Versus Unsupervised Learning, Regression Versus Classification Problems, Assessing Model Accuracy, Measuring the Quality of Fit, The Bias-Variance Trade-Off, The Classification Setting, Lab: Introduction to R, Basic Commands, Graphics, Indexing Data, Loading Data, Additional Graphical and Numerical Summaries, Exercises, Linear Regression, Simple Linear Regression, Estimating the Coefficients, Assessing the Accuracy of the Coefficient Estimates, Assessing the Accuracy of the Model, Multiple Linear Regression, Estimating the Regression Coefficients, Some Important Questions, Other Considerations in the Regression Model, Qualitative Predictors, Extensions of the Linear Model, Potential Problems, The Marketing Plan, Comparison of Linear Regression with K-Nearest Neighbors, Lab: Linear Regression, Libraries, Simple Linear Regression, Multiple Linear Regression, Interaction Terms, Non-linear Transformations of the Predictors, Qualitative Predictors, Writing Functions, Exercises, Classification, An Overview of Classification, Why Not Linear Regression?, Logistic Regression, The Logistic Model, Estimating the Regression Coefficients, Making Predictions, Multiple Logistic Regression, Logistic Regression for >2 Response Classes, Linear Discriminant Analysis, Using Bayes’ Theorem for Classification, Linear Discriminant Analysis for p = 1, Linear Discriminant Analysis for p >1, Quadratic Discriminant Analysis, A Comparison of Classification Methods, Lab: Logistic Regression, LDA, QDA, and KNN, The Stock Market Data, Logistic Regression, Linear Discriminant Analysis, Quadratic Discriminant Analysis, K-Nearest Neighbors, An Application to Caravan Insurance Data, Exercises, Resampling Methods, Cross-Validation, The Validation Set Approach, Leave-One-Out Cross-Validation, k-Fold Cross-Validation, Bias-Variance Trade-Off for k-Fold Cross-Validation, Cross-Validation on Classification Problems, The Bootstrap, Lab: Cross-Validation and the Bootstrap, The Validation Set Approach, Leave-One-Out Cross-Validation, k-Fold Cross-Validation, The Bootstrap, Exercises, Linear Model Selection and Regularization, Subset Selection, Best Subset Selection, Stepwise Selection, Choosing the Optimal Model, Shrinkage Methods, Ridge Regression, The Lasso, Selecting the Tuning Parameter, Dimension Reduction Methods, Principal Components Regression, Partial Least Squares, Considerations in High Dimensions, High-Dimensional Data, What Goes Wrong in High Dimensions?, Regression in High Dimensions, Lab 1: Subset Selection Methods, Best Subset Selection, Forward and Backward Stepwise Selection, Choosing Among Models Using the Validation Set Approach and Cross-Validation, Lab 2: Ridge Regression and the Lasso, Ridge Regression, The Lasso, Lab 3: PCR and PLS Regression, Principal Components Regression, Partial Least Squares, Exercises, Moving Beyond Linearity, Polynomial Regression, Step Functions, Basis Functions, Regression Splines, Piecewise Polynomials, Constraints and Splines, The Spline Basis Representation, Choosing the Number and Locations of the Knots, Comparison to Polynomial Regression, Smoothing Splines, An Overview of Smoothing Splines, Choosing the Smoothing Parameter λ, Local Regression, Generalized Additive Models, GAMs for Regression Problems, GAMs for Classification Problems, Lab: Non-linear Modeling, Polynomial Regression and Step Functions, Splines, GAMs, Exercises, Tree-Based Methods, The Basics of Decision Trees, Regression Trees, Classification Trees, Trees Versus Linear Models, Advantages and Disadvantages of Trees, Bagging, Random Forests, Boosting, Bagging, Random Forests, Boosting, Lab: Decision Trees, Fitting Classification Trees, Fitting Regression Trees, Bagging and Random Forests, Boosting, Exercises, Support Vector Machines, Maximal Margin Classifier, What Is a Hyperplane?, Classification Using a Separating Hyperplane, The Maximal Margin Classifier, Construction of the Maximal Margin Classifier, The Non-separable Case, Support Vector Classifiers, Overview of the Support Vector Classifier, Details of the Support Vector Classifier, Support Vector Machines, Classification with Non-linear Decision Boundaries, The Support Vector Machine, An Application to the Heart Disease Data, SVMs with More than Two Classes, One-Versus-One Classification, One-Versus-All Classification, Relationship to Logistic Regression, Lab: Support Vector Machines, Support Vector Classifier, Support Vector Machine, ROC Curves, SVM with Multiple Classes, Application to Gene Expression Data, Exercises, Unsupervised Learning, The Challenge of Unsupervised Learning, Principal Components Analysis, What Are Principal Components?, Another Interpretation of Principal Components, More on PCA, Clustering Methods, K-Means Clustering, Hierarchical Clustering, Practical Issues in Clustering, Lab 1: Principal Components Analysis, Lab 2: Clustering, K-Means Clustering, Hierarchical Clustering, Lab 3: NCI60 Data Example, PCA on the NCI60 Data, Clustering the Observations of the NCI60 Data, Exercises, Index.

# Engenharia de Prompt para Devs

Um guia para aprender a usar a IA antes que a IA aprenda a usar você
Sumário 1 Modelos de linguagem 1.1 Conceitos e história da Inteligência Artificial 1.2 O que são modelos de linguagem 2 Engenharia de prompt 2.1 Definição e conceito de engenharia de prompt 2.2 A importância da engenharia de prompt na IA e PLN 2.3 Aplicações da engenharia de prompt 2.4 Aplicações da engenharia de prompt na análise e no desenvolvimento de sistemas 2.5 A profissão de Engenharia de Prompt 3 Elaboração de prompts 3.1 A instrução (ou pergunta) 3.2 A resposta (ou ação esperada) 3.3 O contexto conversacional 4 Testes de prompts 4.1 Teste manual 4.2 Teste iterativo 4.3 Teste de múltiplas variações 4.4 Teste de casos extremos de prompts 4.5 Teste com diferentes modelos de linguagem 5 Organização de prompts 5.1 Identificando necessidades e objetivos 5.2 Organizando um banco de prompts 5.3 Organizando contextos e padronizando respostas 5.4 Garantindo continuidade das interações 5.5 Utilizando fontes externas 5.6 Abordagem multilíngue e cultural 5.7 Considerações éticas e de privacidade 5.8 Considerações legais sobre sigilo e confidencialidade 6 IA e o programador moderno 6.1 O que a IA pode fazer por você 6.2 O que a IA NÃO pode fazer por você 6.3 O perfil do novo analista de sistemas 7 Prompts de apoio à modelagem 7.1 Especificando requisitos funcionais 7.2 Estimando esforço e prazos 7.3 Especificando requisitos técnicos 7.4 Organizando as tarefas de um projeto 7.5 Gerando diagramas UML 8 Prompts de apoio à codificação 8.1 Gerando um pseudocódigo próprio 8.2 Gerando ícones e imagens 8.3 Simulando interação com sistemas ou serviços 8.4 Gerando modelos de dados 8.5 Obtendo instruções detalhadas 8.6 Desenvolvendo plugins para múltiplas plataformas 8.7 Gerando fragmentos de código para construir uma solução completa 9 Prompts de apoio a testes e revisão de código 9.1 Testando seu código-fonte 9.2 Analisando a segurança do seu código 10 Prompts de apoio à documentação 10.1 Documentando seu projeto 10.2 Automatizando publicações 10.3 Mantendo código-fonte 11 Modelos de Linguagem de Código (Code Language Models) 11.1 GitHub Copilot 12 Desafios e tendências futuras na Engenharia de Prompt 12.1 Lidando com vieses e controvérsias nos prompts 12.2 Avanços em modelos de linguagem e suas implicações na Engenharia de Prompt 12.3 O que será dos direitos autorais 12.4 O futuro da interação humano-IA por meio de prompts 12.5 Conclusão 13 Referências

# Cloud native with kubernetes

Foreword from NGINX Foreword to the Second Edition Foreword to the First Edition Preface Revolution in the Cloud The Creation of the Cloud Buying Time Infrastructure as a Service The Dawn of DevOps Improving Feedback Loops What Does DevOps Mean? Infrastructure as Code Learning Together The Coming of Containers The State of the Art Thinking Inside the Box Putting Software in Containers Plug and Play Applications Conducting the Container Orchestra Kubernetes From Borg to Kubernetes Why Kubernetes? Will Kubernetes Disappear? Kubernetes Is Not a Panacea First Steps with Kubernetes Running Your First Container Installing Docker Desktop What Is Docker? Running a Container Image The Demo Application Looking at the Source Code Introducing Go How the Demo App Works Building a Container Understanding Dockerfiles Minimal Container Images Running Docker Image Build Naming Your Images Port Forwarding Container Registries Authenticating to the Registry Naming and Pushing Your Image Running Your Image Hello, Kubernetes Running the Demo App If the Container Doesn’t Start Minikube Summary Getting Kubernetes Cluster Architecture The Control Plane Node Components High Availability The Costs of Self-Hosting Kubernetes It’s More Work Than You Think It’s Not Just About the Initial Setup Tools Don’t Do All the Work for You Kubernetes the Hard Way Kubernetes Is Hard Administration Overhead Start with Managed Services Managed Kubernetes Services Google Kubernetes Engine (GKE) Cluster Autoscaling Autopilot Amazon Elastic Kubernetes Service (EKS) Azure Kubernetes Service (AKS) IBM Cloud Kubernetes Service DigitalOcean Kubernetes Kubernetes Installers kops Kubespray kubeadm Rancher Kubernetes Engine (RKE) Puppet Kubernetes Module Buy or Build: Our Recommendations Run Less Software Use Managed Kubernetes if You Can But What About Vendor Lock-in? Bare-Metal and On-Prem Multicloud Kubernetes Clusters OpenShift Anthos Use Standard Kubernetes Self-Hosting Tools if You Must Clusterless Container Services AWS Fargate Azure Container Instances (ACI) Google Cloud Run Summary Working with Kubernetes Objects Deployments Supervising and Scheduling Restarting Containers Creating Deployments Pods ReplicaSets Maintaining Desired State The Kubernetes Scheduler Resource Manifests in YAML Format 59 Resources Are Data 59 Deployment Manifests 59 Using kubectl apply 60 Service Resources 61 Querying the Cluster with kubectl 63 Taking Resources to the Next Level 64 Helm: A Kubernetes Package Manager 64 Installing Helm 65 Installing a Helm Chart 65 Charts, Repositories, and Releases 66 Listing Helm Releases 67 Summary 67 Managing Resources 69 Understanding Resources 69 Resource Units 70 Resource Requests 70 Resource Limits 71 Quality of Service 71 Managing the Container Life Cycle 72 Liveness Probes 72 Probe Delay and Frequency 73 Other Types of Probes 73 Readiness Probes 74 Startup Probes 75 gRPC Probes 75 File-Based Readiness Probes 76 minReadySeconds 76 Pod Disruption Budgets 77 Using Namespaces 78 Working with Namespaces 79 What Namespaces Should I Use? 79 Service Addresses 80 Resource Quotas 80 Default Resource Requests and Limits 82 Optimizing Cluster Costs 83 Kubecost 83 Optimizing Deployments 83 Optimizing Pods 84 Vertical Pod Autoscaler 85 Optimizing Nodes 85 Optimizing Storage 86 Cleaning Up Unused Resources 87 Checking Spare Capacity 89 Using Reserved Instances 90 Using Preemptible (Spot) Instances 90 Keeping Your Workloads Balanced 92 Summary 94 Operating Clusters 97 Cluster Sizing and Scaling 97 Capacity Planning 98 Nodes and Instances 101 Scaling the Cluster 103 Conformance Checking 104 CNCF Certification 105 Conformance Testing with Sonobuoy 106 Kubernetes Audit Logging 108 Chaos Testing 108 Only Production Is Production 109 chaoskube 109 kube-monkey 110 PowerfulSeal 110 Summary 111 Kubernetes Power Tools 113 Mastering kubectl 113 Shell Aliases 113 Using Short Flags 114 Abbreviating Resource Types 114 Auto-Completing kubectl Commands 115 Getting Help 115 Getting Help on Kubernetes Resources 116 Showing More Detailed Output 116 Working with JSON Data and jq 116 Watching Objects 117 Describing Objects 118 Working with Resources 118 Imperative kubectl Commands 118 When Not to Use Imperative Commands 119 Generating Resource Manifests 120 Exporting Resources 120 Diffing Resources 120 Working with Containers 121 Viewing a Container’s Logs 121 Attaching to a Container 122 Watching Kubernetes Resources with kubespy 123 Forwarding a Container Port 123 Executing Commands on Containers 123 Running Containers for Troubleshooting 124 Using BusyBox Commands 125 Adding BusyBox to Your Containers 126 Installing Programs on a Container 127 Contexts and Namespaces 127 kubeconfig files 128 kubectx and kubens 129 kube-ps1 130 Kubernetes Shells and Tools 130 kube-shell 130 Click 130 kubed-sh 131 Stern 131 Kubernetes IDEs 131 Lens 132 VS Code Kubernetes Extension 132 Building Your Own Kubernetes Tools 132 Summary 133 Running Containers 135 Containers and Pods 135 What Is a Container? 136 Container Runtimes in Kubernetes 137 What Belongs in a Container? 137 What Belongs in a Pod? 138 Container Manifests 139 Image Identifiers 139 The latest Tag 140 Container Digests 141 Base Image Tags 141 Ports 142 Resource Requests and Limits 142 Image Pull Policy 143 Environment Variables 143 Container Security 144 Running Containers as a Non-Root User 144 Blocking Root Containers 145 Setting a Read-Only Filesystem 146 Disabling Privilege Escalation 146 Capabilities 146 Pod Security Contexts 148 Pod Service Accounts 148 Volumes 148 emptyDir Volumes 149 Persistent Volumes 150 Restart Policies 151 Image Pull Secrets 151 Init Containers 152 Summary 152 Managing Pods 155 Labels 155 What Are Labels? 155 Selectors 156 More Advanced Selectors 157 Other Uses for Labels 158 Labels and Annotations 159 Node Affinities 159 Hard Affinities 160 Soft Affinities 160 Pod Affinities and Anti-Affinities 161 Keeping Pods Together 161 Keeping Pods Apart 162 Soft Anti-Affinities 163 When to Use Pod Affinities 163 Taints and Tolerations 164 Pod Controllers 165 DaemonSets 166 StatefulSets 167 Jobs 168 CronJobs 169 Horizontal Pod Autoscalers 169 Operators and Custom Resource Definitions (CRDs) 172 Ingress 173 Ingress Controllers 174 Ingress Rules 175 Terminating TLS with Ingress 175 Service Mesh 176 Istio 177 Linkerd 177 Consul Connect 177 NGINX Service Mesh 177 Summary 177 Configuration and Secrets 181 ConfigMaps 181 Creating ConfigMaps 182 Setting Environment Variables from ConfigMaps 183 Setting the Whole Environment from a ConfigMap 185 Using Environment Variables in Command Arguments 186 Creating Config Files from ConfigMaps 187 Updating Pods on a Config Change 188 Kubernetes Secrets 189 Using Secrets as Environment Variables 189 Writing Secrets to Files 190 Reading Secrets 191 Access to Secrets 192 Encryption at Rest 192 Keeping Secrets and ConfigMaps 192 Secrets Management Strategies 193 Encrypt Secrets in Version Control 193 Use a Dedicated Secrets Management Tool 194 Encrypting Secrets with Sops 195 Encrypting a File with Sops 195 Using a KMS Backend 197 Sealed Secrets 197 Summary 197 Security, Backups, and Cluster Health 199 Access Control and Permissions 199 Managing Access by Cluster 199 Introducing Role-Based Access Control (RBAC) 200 Understanding Roles 201 Binding Roles to Users 201 What Roles Do I Need? 202 Guard Access to cluster-admin 202 Applications and Deployment 203 RBAC Troubleshooting 204 Cluster Security Scanning 205 Gatekeeper/OPA 205 kube-bench 205 Kubescape 206 Container Security Scanning 206 Clair 206 Aqua 207 Anchore Engine 207 Synk 207 Backups 208 Do I Need to Back Up Kubernetes? 209 Backing Up etcd 209 Backing Up Resource State 210 Backing Up Cluster State 210 Large and Small Disasters 211 Velero 211 Monitoring Cluster Status 214 kubectl 214 CPU and Memory Utilization 216 Cloud Provider Console 216 Kubernetes Dashboard 217 Weave Scope 218 kube-ops-view 218 node-problem-detector 218 Further Reading 218 Summary 219 Deploying Kubernetes Applications 221 Building Manifests with Helm 221 What’s Inside a Helm Chart? 222 Helm Templates 223 Interpolating Variables 224 Quoting Values in Templates 225 Specifying Dependencies 225 Deploying Helm Charts 225 Setting Variables 226 Specifying Values in a Helm Release 226 Updating an App with Helm 227 Rolling Back to Previous Versions 228 Creating a Helm Chart Repo 228 Managing Helm Chart Secrets with Sops 229 Managing Multiple Charts with Helmfile 231 What’s in a Helmfile? 231 Chart Metadata 232 Applying the Helmfile 232 Advanced Manifest Management Tools 233 kustomize 234 Tanka 235 Kapitan 236 kompose 236 Ansible 236 kubeval 237 Summary 237 Development Workflow 239 Development Tools 239 Skaffold 239 Telepresence 241 Waypoint 241 Knative 242 OpenFaaS 242 Crossplane 242 Deployment Strategies 244 Rolling Updates 244 Recreate 245 maxSurge and maxUnavailable 245 Blue/Green Deployments 246 Rainbow Deployments 247 Canary Deployments 247 Handling Migrations with Helm 248 Helm Hooks 248 Handling Failed Hooks 249 Other Hooks 249 Chaining Hooks 250 Summary 250 Continuous Deployment in Kubernetes 253 What Is Continuous Deployment? 253 Which CD Tool Should I Use? 254 Hosted CI/CD Tools 254 Azure Pipelines 255 Google Cloud Build 255 Codefresh 255 GitHub Actions 255 GitLab CI 256 Self-Hosted CI/CD Tools 256 Jenkins 256 Drone 256 Tekton 256 Concourse 256 Spinnaker 257 Argo 257 Keel 257 A CI/CD Pipeline with Cloud Build 257 Setting Up Google Cloud and GKE 258 Forking the Demo Repository 258 Create Artifact Registry Container Repository 258 Configuring Cloud Build 259 Building the Test Container 259 Running the Tests 260 Building the Application Container 260 Substitution Variables 260 Git SHA Tags 261 Validating the Kubernetes Manifests 261 Publishing the Image 262 Creating the First Build Trigger 262 Testing the Trigger 262 Deploying from a CI/CD Pipeline 263 Creating a Deploy Trigger 265 Adapting the Example Pipeline 266 GitOps 266 Flux 266 Summary 268 Observability and Monitoring 271 What Is Observability? 271 What Is Monitoring? 271 Closed-Box Monitoring 271 What Does “Up” Mean? 273 Logging 274 Introducing Metrics 276 Tracing 277 Observability 278 The Observability Pipeline 279 Monitoring in Kubernetes 280 External Closed-Box Checks 280 Internal Health Checks 282 Summary 283 Metrics in Kubernetes 285 What Are Metrics, Really? 285 Time-Series Data 285 Counters and Gauges 286 What Can Metrics Tell Us? 287 Choosing Good Metrics 287 Services: The RED Pattern 288 Resources: The USE Pattern 289 Business Metrics 290 Kubernetes Metrics 291 Analyzing Metrics 294 What’s Wrong with a Simple Average? 295 Means, Medians, and Outliers 295 Discovering Percentiles 296 Applying Percentiles to Metrics Data 296 We Usually Want to Know the Worst 298 Beyond Percentiles 298 Graphing Metrics with Dashboards 299 Use a Standard Layout for All Services 299 Build an Information Radiator with Primary Dashboards 300 Dashboard Things That Break 301 Alerting on Metrics 303 What’s Wrong with Alerts? 303 On-Call Should Not Be Hell 304 Urgent, Important, and Actionable Alerts 304 Track Your Alerts, Out-of-Hours Pages, and Wake-Ups 305 Metrics Tools and Services 306 Prometheus 306 Google Operations Suite 308 AWS CloudWatch 309 Azure Monitor 309 Datadog 309 New Relic 310 Summary 311 Afterword 313 Index 317

# kubernetes best practivces

Setting Up a Basic Service 1 Application Overview 1 Managing Configuration Files 2 Creating a Replicated Service Using Deployments 3 Best Practices for Image Management 4 Creating a Replicated Application 4 Setting Up an External Ingress for HTTP Traffic 6 Configuring an Application with ConfigMaps 8 Managing Authentication with Secrets 9 Deploying a Simple Stateful Database 12 Creating a TCP Load Balancer by Using Services 16 Using Ingress to Route Traffic to a Static File Server 17 Parameterizing Your Application by Using Helm 19 Deploying Services Best Practices 21 Summary 21 Developer Workflows 23 Goals 23 Building a Development Cluster 24 Setting Up a Shared Cluster for Multiple Developers 25 Onboarding Users 26 Creating and Securing a Namespace 29 Managing Namespaces 30 Cluster-Level Services 31 Enabling Developer Workflows 31 Initial Setup 32 Enabling Active Development 33 Enabling Testing and Debugging 34 Setting Up a Development Environment Best Practices 34 Summary 35 Monitoring and Logging in Kubernetes 37 Metrics Versus Logs 37 Monitoring Techniques 37 Monitoring Patterns 38 Kubernetes Metrics Overview 39 cAdvisor 39 Metrics Server 40 kube-state-metrics 40 What Metrics Do I Monitor? 41 Monitoring Tools 42 Monitoring Kubernetes Using Prometheus 44 Logging Overview 48 Tools for Logging 49 Logging by Using a Loki-Stack 50 Alerting 53 Best Practices for Monitoring, Logging, and Alerting 54 Summary 55 Configuration, Secrets, and RBAC 57 Configuration Through ConfigMaps and Secrets 57 ConfigMaps 58 Secrets 58 Common Best Practices for the ConfigMap and Secrets APIs 59 Best Practices Specific to Secrets 64 RBAC 65 RBAC Primer 66 RBAC Best Practices 68 Summary 69 Continuous Integration, Testing, and Deployment 71 Version Control 72 Continuous Integration 72 Testing 73 Container Builds 73 Container Image Tagging 74 Continuous Deployment 75 Deployment Strategies 75 Testing in Production 80 Setting Up a Pipeline and Performing a Chaos Experiment 81 Setting Up CI 81 Setting Up CD 84 Performing a Rolling Upgrade 84 A Simple Chaos Experiment 85 Best Practices for CI/CD 85 Summary 86 Versioning, Releases, and Rollouts 87 Versioning 88 Releases 88 Rollouts 89 Putting It All Together 90 Best Practices for Versioning, Releases, and Rollouts 93 Summary 94 Worldwide Application Distribution and Staging 95 Distributing Your Image 96 Parameterizing Your Deployment 97 Load-Balancing Traffic Around the World 98 Reliably Rolling Out Software Around the World 98 Pre-Rollout Validation 99 Canary Region 102 Identifying Region Types 103 Constructing a Global Rollout 103 When Something Goes Wrong 104 Worldwide Rollout Best Practices 105 Summary 106 Resource Management 107 Kubernetes Scheduler 107 Predicates 107 Priorities 108 Advanced Scheduling Techniques 109 Pod Affinity and Anti-Affinity 109 nodeSelector 110 Taints and Tolerations 110 Pod Resource Management 112 Resource Request 112 Resource Limits and Pod Quality of Service 113 PodDisruptionBudgets 115 Managing Resources by Using Namespaces 116 ResourceQuota 117 LimitRange 119 Cluster Scaling 120 Application Scaling 121 Scaling with HPA 122 HPA with Custom Metrics 123 Vertical Pod Autoscaler 123 Resource Management Best Practices 124 Summary 124 Networking, Network Security, and Service Mesh 125 Kubernetes Network Principles 125 Network Plug-ins 128 Kubenet 129 Kubenet Best Practices 129 The CNI Plug-in 129 CNI Best Practices 130 Services in Kubernetes 130 Service Type ClusterIP 131 Service Type NodePort 132 Service Type ExternalName 134 Service Type LoadBalancer 134 Ingress and Ingress Controllers 136 Gateway API 137 Services and Ingress Controllers Best Practices 139 Network Security Policy 140 Network Policy Best Practices 142 Service Meshes 143 Service Mesh Best Practices 145 Summary 145 Pod and Container Security 147 Pod Security Admission Controller 147 Enabling Pod Security Admission 148 Pod Security levels 148 Activating Pod Security Using Namespace Labels 149 Workload Isolation and RuntimeClass 150 Using RuntimeClass 151 Runtime Implementations 151 Workload Isolation and RuntimeClass Best Practices 152 Other Pod and Container Security Considerations 153 Admission Controllers 153 Intrusion and Anomaly Detection Tooling 153 Summary 153 Policy and Governance for Your Cluster 155 Why Policy and Governance Are Important 155 How Is This Policy Different? 155 Cloud Native Policy Engine 156 Introducing Gatekeeper 156 Example Policies 157 Gatekeeper Terminology 157 Defining Constraint Templates 158 Defining Constraints 159 Data Replication 160 UX 161 Using Enforcement Action and Audit 161 Mutation 163 Testing Policies 163 Becoming Familiar with Gatekeeper 163 Policy and Governance Best Practices 164 Summary 165 Managing Multiple Clusters 167 Why Multiple Clusters? 167 Multicluster Design Concerns 169 Managing Multiple Cluster Deployments 171 Deployment and Management Patterns 171 The GitOps Approach to Managing Clusters 173 Multicluster Management Tools 175 Kubernetes Federation 176 Managing Multiple Clusters Best Practices 176 Summary 177 Integrating External Services with Kubernetes 179 Importing Services into Kubernetes 179 Selector-Less Services for Stable IP Addresses 180 CNAME-Based Services for Stable DNS Names 181 Active Controller-Based Approaches 182 Exporting Services from Kubernetes 183 Exporting Services by Using Internal Load Balancers 184 Exporting Services on NodePorts 184 Integrating External Machines and Kubernetes 185 Sharing Services Between Kubernetes 186 Third-Party Tools 187 Connecting Cluster and External Services Best Practices 188 Summary 188 Running Machine Learning in Kubernetes 189 Why Is Kubernetes Great for Machine Learning? 189 Machine Learning Workflow 190 Machine Learning for Kubernetes Cluster Admins 191 Model Training on Kubernetes 192 Distributed Training on Kubernetes 195 Resource Constraints 195 Specialized Hardware 196 Libraries, Drivers, and Kernel Modules 197 Storage 197 Networking 198 Specialized Protocols 198 Data Scientist Concerns 199 Machine Learning on Kubernetes Best Practices 199 Summary 201 Building Higher-Level Application Patterns on Top of Kubernetes 203 Approaches to Developing Higher-Level Abstractions 203 Extending Kubernetes 204 Extending Kubernetes Clusters 205 Extending the Kubernetes User Experience 206 Making Containerized Development Easier 207 Developing a “Push-to-Deploy” Experience 207 Design Considerations When Building Platforms 208 Support Exporting to a Container Image 208 Support Existing Mechanisms for Service and Service Discovery 209 Building Application Platforms Best Practices 209 Summary 210 Managing State and Stateful Applications 211 Volumes and Volume Mounts 212 Volume Best Practices 213 Kubernetes Storage 213 PersistentVolume 213 PersistentVolumeClaims 214 StorageClasses 215 Kubernetes Storage Best Practices 216 Stateful Applications 217 StatefulSets 218 Operators 220 StatefulSet and Operator Best Practices 221 Summary 222 Admission Control and Authorization 223 Admission Control 224 What Are They? 224 Why Are They Important? 224 Admission Controller Types 225 Configuring Admission Webhooks 226 Admission Control Best Practices 228 Authorization 231 Authorization Modules 231 Authorization Best Practices 234 Summary 234 GitOps and Deployment 235 What Is GitOps? 236 Why GitOps? 237 GitOps Repo Structure 238 Managing Secrets 240 Setting Up Flux 241 GitOps Tooling 243 GitOps Best Practices 244 Summary 244 Security 245 Cluster Security 246 etcd Access 246 Authentication 246 Authorization 246 TLS 247 Kubelet and Cloud Metadata Access 247 Secrets 247 Logging and Auditing 247 Cluster Security Posture Tooling 248 Cluster Security Best Practices 248 Workload Container Security 248 Pod Security Admission 249 Seccomp, AppArmor, and SELinux 249 Admission Controllers 249 Operators 249 Network Policy 250 Runtime Security 250 Workload Container Security Best Practices 250 Code Security 251 Non-Root and Distroless Containers 251 Container Vulnerability Scanning 252 Code Repository Security 252 Code Security Best Practices 252 Summary 253 Chaos Testing, Load Testing, and Experiments 255 Chaos Testing 255 Load Testing 259 Experiments 263 Chaos Testing, Load Testing, and Experiments Summary 266 Implementing an Operator 267 Operator Key Components 268 Custom Resource Definitions 268 Creating Our API 270 Controller Reconciliation 277 Resource Validation 278 Controller Implementation 279 Operator Life Cycle 284 Version Upgrades 284 Operator Best Practices 285 Summary 286 Conclusion 289 Index 291

# nginx cookbook

Foreword xi Preface xiii Basics Introduction 1 Installing on Debian/Ubuntu 1 Installing on RedHat/CentOS 2 Installing NGINX Plus 3 Verifying Your Installation 3 Key Files, Directories, and Commands 4 Serving Static Content 6 Graceful Reload 7 High-Performance Load Balancing Introduction 9 HTTP Load Balancing 10 TCP Load Balancing 11 UDP Load Balancing 13 Load-Balancing Methods 14 Sticky Cookie with NGINX Plus 16 Sticky Learn with NGINX Plus 17 Sticky Routing with NGINX Plus 18 Connection Draining with NGINX Plus 19 Passive Health Checks 20 Active Health Checks with NGINX Plus 21 Slow Start with NGINX Plus 23 Traffic Management Introduction 25 A/B Testing 25 Using the GeoIP Module and Database 27 Restricting Access Based on Country 29 Finding the Original Client 30 Limiting Connections 31 Limiting Rate 32 Limiting Bandwidth 34 Massively Scalable Content Caching Introduction 37 Caching Zones 37 Cache Locking 38 Caching Hash Keys 39 Cache Bypass 40 Cache Performance 41 Cache Purging with NGINX Plus 41 Cache Slicing 42 Programmability and Automation Introduction 45 NGINX Plus API 45 Using the Key-Value Store with NGINX Plus 49 Extending NGINX with a Common Programming Language 51 Installing with Puppet 54 Installing with Chef 55 Installing with Ansible 56 Installing with SaltStack 58 Automating Configurations with Consul Templating 59 Authentication Introduction 61 HTTP Basic Authentication 61 Authentication Subrequests 63 Validating JWTs with NGINX Plus 64 Creating JSON Web Keys 65 Validate JSON Web Tokens with NGINX Plus 66 Automatically Obtaining and Caching JSON Web Key Sets with NGINX Plus 67 Authenticate Users via Existing OpenID Connect SSO with NGINX Plus 68 Security Controls Introduction 71 Access Based on IP Address 71 Allowing Cross-Origin Resource Sharing 72 Client-Side Encryption 74 Advanced Client-Side Encryption 75 Upstream Encryption 77 Securing a Location 77 Generating a Secure Link with a Secret 78 Securing a Location with an Expire Date 79 Generating an Expiring Link 80 HTTPS Redirects 82 Redirecting to HTTPS Where SSL/TLS Is Terminated Before NGINX 82 HTTP Strict Transport Security 83 Satisfying Any Number of Security Methods 84 NGINX Plus Dynamic Application Layer DDoS Mitigation 85 Installing and Configuring NGINX Plus App Protect Module 86 HTTP/2 Introduction 91 Basic Configuration 91 gRPC 92 HTTP/2 Server Push 94 Sophisticated Media Streaming Introduction 97 Serving MP4 and FLV 97 Streaming with HLS with NGINX Plus 98 Streaming with HDS with NGINX Plus 99 Bandwidth Limits with NGINX Plus 100 Cloud Deployments Introduction 101 Auto-Provisioning on AWS 101 Routing to NGINX Nodes Without an AWS ELB 103 The NLB Sandwich 104 Deploying from the AWS Marketplace 106 Creating an NGINX Virtual Machine Image on Azure 107 Load Balancing Over NGINX Scale Sets on Azure 109 Deploying Through the Azure Marketplace 109 Deploying to Google Compute Engine 110 Creating a Google Compute Image 111 Creating a Google App Engine Proxy 112 Containers/Microservices Introduction 115 Using NGINX as an API Gateway 116 Using DNS SRV Records with NGINX Plus 120 Using the Official NGINX Image 121 Creating an NGINX Dockerfile 122 Building an NGINX Plus Docker Image 124 Using Environment Variables in NGINX 126 Kubernetes Ingress Controller 127 Prometheus Exporter Module 129 High-Availability Deployment Modes Introduction 131 NGINX Plus HA Mode 131 Load-Balancing Load Balancers with DNS 132 Load Balancing on EC2 132 NGINX Plus Configuration Synchronization 133 State Sharing with NGINX Plus and Zone Sync 136 Advanced Activity Monitoring Introduction 139 Enable NGINX Open Source Stub Status 139 Enabling the NGINX Plus Monitoring Dashboard 140 Collecting Metrics Using the NGINX Plus API 143 Debugging and Troubleshooting with Access Logs, Error Logs, and Request Tracing Introduction 147 Configuring Access Logs 147 Configuring Error Logs 149 Forwarding to Syslog 150 Request Tracing 151 OpenTracing for NGINX 152 Performance Tuning Introduction 155 Automating Tests with Load Drivers 155 Keeping Connections Open to Clients 156 Keeping Connections Open Upstream 157 Buffering Responses 158 Buffering Access Logs 159 OS Tuning 159 Introduction to NGINX Controller Introduction 161 Setup Overview 161 Connecting NGINX Plus with Controller 163 Driving NGINX Controller with the API 164 Enable WAF Through Controller App Security 165 Practical Ops Tips and Conclusion Introduction 169 Using Includes for Clean Configs 169 Debugging Configs 170 Conclusion 173 Index 175

# programming aws lambda

Introduction to Serverless, Amazon Web Services, and AWS Lambda A Quick History Lesson 1 The Cloud Grows 3 Enter Serverless 3 Backend as a Service 3 Functions as a Service 4 Differentiating Serverless 5 What Is AWS? 6 Types of Service 6 Capacity 7 Who Uses AWS? 9 How Do You Use AWS? 9 What Is AWS Lambda? 10 Functions as a Service 10 FaaS as Implemented by Lambda 11 Why Lambda? 13 What Does a Lambda Application Look Like? 13 AWS Lambda in the Java World 16 Summary 17 Exercises 18 Getting Started with AWS Lambda Quick Guide to the AWS Console 19 Regions 20 Identity and Access Management 22 Lambda Hello World (as Quickly as Possible) 22 Setting Up Your Development Environment 26 AWS Command Line Interface 26 Java Setup 31 AWS SAM CLI Installation 33 Lambda Hello World (the Proper Way) 34 Creating Your First Java Lambda Project 34 Building Hello World 35 Creating the Lambda Function 35 Summary 38 Exercises 39 Programming AWS Lambda Functions Core Concepts: Runtime Model, Invocation 41 The Lambda Execution Environment 42 Invocation Types 43 Introduction to Logging 46 Input, Output 47 Lambda Function Method Signatures 48 Configuring the Handler Function in the SAM Template 49 Basic Types 49 Lists and Maps 50 POJOs and Ecosystem Types 52 Streams 54 Context 55 Timeout 57 Memory and CPU 59 Environment Variables 61 Summary 63 Exercises 63 Operating AWS Lambda Functions Build and Package 65 Uberjars 66 Assembling a ZIP File 67 Reproducible Builds 71 Deploy 72 Infrastructure as Code 73 CloudFormation and the Serverless Application Model 74 Security 76 The Principle of Least Privilege 77 Identity and Access Management 78 Summary 83 Exercises 83 Building Serverless Applications Lambda Event Sources 86 Writing Code to Work with Input and Output for Event Sources 86 Configuring a Lambda Event Source 90 Understanding Different Event Source Semantics 91 Example: Building a Serverless API 92 Behavior 92 Architecture 93 Lambda Code 95 Build and Package Using the AWS SDK BOM 103 Infrastructure 104 Deployment 107 Example: Building a Serverless Data Pipeline 111 Behavior 112 Architecture 112 Lambda Code 116 Build and Package Using Multiple Modules and Isolated Artifacts 122 Infrastructure 127 Deployment 130 Summary 132 Exercises 133 Testing The Test Pyramid 135 Unit Tests 136 Functional Tests 136 End-to-End Tests 136 Refactoring for Testing 137 Revisiting BulkEventsLambda 137 Refactoring BulkEventsLambda 140 Add Constructors 140 Isolate Side Effects 141 Split Methods 142 Testing BulkEventsLambda 142 Unit Testing 142 Functional Testing 145 End-to-End Testing 149 Local Cloud Testing 153 Cloud Test Environments 154 Summary 156 Exercise 156 Logging, Metrics, and Tracing Logging 157 CloudWatch Logs 158 LambdaLogger 159 Java Logging Frameworks 161 Structured Logging 165 Structured Logging in Java 166 CloudWatch Logs Insights 168 Metrics 170 CloudWatch Metrics 170 Lambda Platform Metrics 171 Business Metrics 172 Alarms 173 Distributed Tracing 175 Finding Errors 177 Summary 180 Exercises 180 Advanced AWS Lambda Error Handling 183 Classes of Error 183 The Various Behaviors of Lambda Error Processing 184 Deep Dive into Asynchronous Event Source Errors 186 Handling Kinesis and DynamoDB Stream Errors 191 Tracing Errors with X-Ray 192 Error Handling Strategies 192 Scaling 193 Observing Lambda Scaling 193 Scaling Limits and Throttling 195 Thread Safety 196 Vertical Scaling 197 Versions and Aliases, Traffic Shifting 198 Lambda Versions 198 Lambda Aliases 198 Traffic Shifting 199 When (Not) to Use Versions and Aliases 201 Cold Starts 201 What Is a Cold Start? 202 When Does a Cold Start Occur? 202 Identifying Cold Starts 203 Impact of Cold Starts 204 Mitigating Cold Starts 205 Provisioned Concurrency 208 Cold Start Summary 211 State 212 Persistent Application State 212 Caching 214 Lambda and Java Application Frameworks 215 Virtual Private Clouds 217 Architectural Concerns of Using Lambda with a VPCs 219 Configuring Lambda to Use a VPC 219 Alternatives 220 Layers and Runtimes 220 What Are Layers? 221 When to Use, and Not Use, Layers 221 Custom Runtimes 223 Summary 224 Exercises 225 Advanced Serverless Architecture Serverless Architecture “Gotchas” 227 At-Least-Once Delivery 227 Impacts of Lambda Scaling on Downstream Systems 230 The “Fine Print” of Lambda Event Sources 235 New Patterns of Architecture Enabled by Serverless Thinking 236 Published Components with the Serverless Application Repository 236 Globally Distributed Applications 238 Summary 244 Exercises 244 Conclusion 245 Index 249
